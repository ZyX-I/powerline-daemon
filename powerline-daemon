#!/usr/bin/env python
# vim:fileencoding=UTF-8:ts=4:sw=4:sta:et:sts=4:fdm=marker:ai
from __future__ import (unicode_literals, division, absolute_import,
                        print_function)

__license__   = 'GPL v3'
__copyright__ = '2013, Kovid Goyal <kovid at kovidgoyal.net>'
__docformat__ = 'restructuredtext en'

import socket, os, argparse, errno, sys

from powerline.shell import ShellPowerline
from powerline.lib import parsedotval

uid = os.getuid()
# Use the abstract namespace for sockets rather than the filesystem (Available
# in linux)
address = '\0powerline-ipc-%d'%uid

parser = argparse.ArgumentParser()
parser.add_argument('ext', nargs=1)
parser.add_argument('side', nargs='?', choices=('left', 'right'))
parser.add_argument('-r', '--renderer_module', metavar='MODULE', type=str)
parser.add_argument('-w', '--width', type=int)
parser.add_argument('--last_exit_code', metavar='INT', type=int)
parser.add_argument('--last_pipe_status', metavar='LIST', default='', type=lambda s: [int(status) for status in s.split()])
parser.add_argument('-c', '--config', metavar='KEY.KEY=VALUE', type=parsedotval, action='append')
parser.add_argument('-t', '--theme_option', metavar='THEME.KEY.KEY=VALUE', type=parsedotval, action='append')
parser.add_argument('-p', '--config_path', metavar='PATH')
parser.add_argument('--cwd', metavar='PATH')

def render(args):
    if args.cwd:
        odir = os.getcwd()
        os.chdir(args.cwd)
    try:
        powerline = ShellPowerline(args)
        return powerline.renderer.render(width=args.width, side=args.side)
    finally:
        if args.cwd:
            os.chdir(odir)

def eintr_retry_call(func, *args, **kwargs):
    while True:
        try:
            return func(*args, **kwargs)
        except EnvironmentError as e:
            if getattr(e, 'errno', None) == errno.EINTR:
                continue
            raise

def do_read(conn):
    read = []
    while not read or not read[-1][-2:] == b'\0\0':
        x = eintr_retry_call(conn.recv, 4096)
        read.append(x)
    return b''.join(read)

def handle_client(conn):
    try:
        try:
            req = do_read(conn)
        except Exception:
            return
        if req:
            if req == b'EOF\0\0':
                raise SystemExit(0)
            try:
                args = [x for x in req.split(b'\0') if x]
                args = parser.parse_args(args)
                ans = render(args)
            except (Exception, SystemExit) as e:
                ans = str(e)
            if isinstance(ans, type(u'')):
                ans = ans.encode('utf-8')
            try:
                eintr_retry_call(conn.sendall, ans+b'\0')
            except Exception:
                pass
    finally:
        conn.close()

def main_loop(sock):
    sock.listen(1)
    sock.setblocking(0)
    try:
        while True:
            try:
                conn, _ = eintr_retry_call(sock.accept)
            except socket.error:
                continue
            handle_client(conn)
    except KeyboardInterrupt:
        raise SystemExit(0)

def daemonize(stdin=os.devnull, stdout=os.devnull, stderr=os.devnull):
    try:
        pid = os.fork()
        if pid > 0:
            # exit first parent
            sys.exit(0)
    except OSError as e:
        print ("fork #1 failed: %d (%s)" % (e.errno, e.strerror),
               file=sys.stderr)
        sys.exit(1)

    # decouple from parent environment
    os.chdir("/")
    os.setsid()
    os.umask(0)

    # do second fork
    try:
        pid = os.fork()
        if pid > 0:
            # exit from second parent
            sys.exit(0)
    except OSError as e:
        print ("fork #2 failed: %d (%s)" % (e.errno, e.strerror),
               file=sys.stderr)
        sys.exit(1)

    # Redirect standard file descriptors.
    si = file(stdin, 'r')
    so = file(stdout, 'a+')
    se = file(stderr, 'a+', 0)
    os.dup2(si.fileno(), sys.stdin.fileno())
    os.dup2(so.fileno(), sys.stdout.fileno())
    os.dup2(se.fileno(), sys.stderr.fileno())

def check_existing():
    sock = socket.socket(family=socket.AF_UNIX)
    try:
        sock.bind(address)
    except socket.error as e:
        if getattr(e, 'errno', None) == errno.EADDRINUSE:
            return None
        raise
    return sock

def main():
    p = argparse.ArgumentParser(description=
        'Daemon to improve the performance of powerline')
    a = p.add_mutually_exclusive_group().add_argument
    a('--kill', '-k', action='store_true', help=
      'Kill an already running instance')
    a('--foreground', '-f', action='store_true', help=
      'Run in the foreground (dont daemonize)')
    args = p.parse_args()
    if args.kill:
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        try:
            sock.connect(address)
        except socket.error:
            print ('No running daemon found')
            return
        sock.sendall(b'EOF\0\0')
        sock.close()
        print ('Kill command sent to daemon, if it does not die in a couple of seconds use kill to kill it')
        return
    sock = check_existing()
    if sock is None:
        print ('The daemon is already running.')
        raise SystemExit(1)

    if args.foreground:
        return main_loop(sock)
    daemonize()
    main_loop(sock)

if __name__ == '__main__':
    main()

