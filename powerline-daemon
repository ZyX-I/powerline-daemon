#!/usr/bin/env python
# vim:fileencoding=UTF-8:ts=4:sw=4:sta:et:sts=4:fdm=marker:ai
from __future__ import (unicode_literals, division, absolute_import,
                        print_function)

__license__   = 'GPL v3'
__copyright__ = '2013, Kovid Goyal <kovid at kovidgoyal.net>'
__docformat__ = 'restructuredtext en'

import socket, os, argparse, errno, sys, select, time

from powerline.shell import ShellPowerline, get_argparser

# Use the abstract namespace for sockets rather than the filesystem (Available
# in linux)
address = '\0powerline-ipc-%d'%os.getuid()

class NonInteractiveArgParser(argparse.ArgumentParser):

    def print_usage(self, file=None):
        raise Exception(self.format_usage())

    def print_help(self, file=None):
        raise Exception(self.format_help())

    def exit(self, status=0, message=None):
        pass

    def error(self, message):
        raise Exception(self.format_usage())

parser = get_argparser(parser=NonInteractiveArgParser, usage='powerline daemon')
parser.add_argument('--cwd', metavar='PATH')

EOF = b'EOF\0\0'

def render(args):
    if args.cwd:
        odir = os.getcwd()
        try:
            os.chdir(args.cwd)
        except EnvironmentError:
            pass # cwd does not exist/No permissions to execute it
    try:
        powerline = ShellPowerline(args)
        return powerline.renderer.render(width=args.width, side=args.side)
    finally:
        if args.cwd:
            os.chdir(odir)

def eintr_retry_call(func, *args, **kwargs):
    while True:
        try:
            return func(*args, **kwargs)
        except EnvironmentError as e:
            if getattr(e, 'errno', None) in (errno.EINTR, errno.EBUSY, errno.EAGAIN):
                continue
            raise

def do_read(conn, timeout=2.0):
    ''' Read data from the client. If the client fails to send data within
    timeout seconds, abort. '''
    read = []
    end_time = time.time() + timeout
    while not read or not read[-1].endswith(b'\0\0'):
        r, w, e = select.select((conn,), (), (conn,), timeout)
        if e:
            return
        if time.time() > end_time:
            return
        if not r:
            continue
        x = eintr_retry_call(conn.recv, 4096)
        if x:
            read.append(x)
        else:
            break
    return b''.join(read)

def do_write(conn, result):
    try:
        eintr_retry_call(conn.sendall, result+b'\0')
    except Exception:
        pass

def do_render(req):
    try:
        args = [x for x in req.split(b'\0') if x]
        args = parser.parse_args(args)
        ans = render(args)
    except Exception as e:
        ans = str(e)
    if isinstance(ans, type(u'')):
        ans = ans.encode('utf-8')
    return ans

def do_one(sock, read_sockets, write_sockets, result_map):
    r, w, e = select.select(
        tuple(read_sockets)+(sock,), tuple(write_sockets),
        tuple(read_sockets)+tuple(write_sockets)+(sock,),
        60.0)

    if sock in e:
        # We cannot accept any more connections, so we exit
        raise SystemExit(1)

    for s in e:
        # Discard all broken connections to clients
        s.close()
        read_sockets.discard(s)
        write_sockets.discard(s)

    for s in r:
        if s == sock:
            # A client wants to connect
            conn, _ = eintr_retry_call(sock.accept)
            read_sockets.add(conn)
        else:
            # A client has sent some data
            read_sockets.discard(s)
            req = do_read(s)
            if req == EOF:
                raise SystemExit(0)
            elif req:
                ans = do_render(req)
                result_map[s] = ans
                write_sockets.add(s)
            else:
                s.close()

    for s in w:
        # A client is ready to receive the result
        write_sockets.discard(s)
        result = result_map.pop(s)
        try:
            do_write(s, result)
        finally:
            s.close()

def main_loop(sock):
    sock.listen(1)
    sock.setblocking(0)

    read_sockets, write_sockets = set(), set()
    result_map = {}
    try:
        while True:
            do_one(sock, read_sockets, write_sockets, result_map)
    except KeyboardInterrupt:
        raise SystemExit(0)
    return 0

def daemonize(stdin=os.devnull, stdout=os.devnull, stderr=os.devnull):
    try:
        pid = os.fork()
        if pid > 0:
            # exit first parent
            sys.exit(0)
    except OSError as e:
        print ("fork #1 failed: %d (%s)" % (e.errno, e.strerror),
               file=sys.stderr)
        sys.exit(1)

    # decouple from parent environment
    os.chdir("/")
    os.setsid()
    os.umask(0)

    # do second fork
    try:
        pid = os.fork()
        if pid > 0:
            # exit from second parent
            sys.exit(0)
    except OSError as e:
        print ("fork #2 failed: %d (%s)" % (e.errno, e.strerror),
               file=sys.stderr)
        sys.exit(1)

    # Redirect standard file descriptors.
    si = file(stdin, 'r')
    so = file(stdout, 'a+')
    se = file(stderr, 'a+', 0)
    os.dup2(si.fileno(), sys.stdin.fileno())
    os.dup2(so.fileno(), sys.stdout.fileno())
    os.dup2(se.fileno(), sys.stderr.fileno())

def check_existing():
    sock = socket.socket(family=socket.AF_UNIX)
    try:
        sock.bind(address)
    except socket.error as e:
        if getattr(e, 'errno', None) == errno.EADDRINUSE:
            return None
        raise
    return sock

def test_connect():
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    try:
        try:
            eintr_retry_call(sock.connect, address)
        except socket.error:
            return False
        else:
            eintr_retry_call(sock.sendall, EOF)
    finally:
        sock.close()
    return True

def main():
    p = argparse.ArgumentParser(description=
        'Daemon to improve the performance of powerline')
    a = p.add_mutually_exclusive_group().add_argument
    a('--kill', '-k', action='store_true', help=
      'Kill an already running instance')
    a('--foreground', '-f', action='store_true', help=
      'Run in the foreground (dont daemonize)')
    a('--replace', '-r', action='store_true', help=
      'Replace an already running instance')
    args = p.parse_args()
    if args.kill:
        if test_connect():
            print ('Kill command sent to daemon, if it does not die in a couple of seconds use kill to kill it')
        else:
            print ('No running daemon found')
        return
    if args.replace:
        while test_connect():
            time.sleep(2)
    sock = check_existing()
    if sock is None:
        print ('The daemon is already running. Use %s -k to kill it.'%
               os.path.basename(sys.argv[0]), file=sys.stderr)
        raise SystemExit(1)

    if args.foreground:
        return main_loop(sock)
    daemonize()
    main_loop(sock)

if __name__ == '__main__':
    main()

